{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { useFBO } from './useFBO.js';\nimport { RenderTexture } from './RenderTexture.js';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { FullScreenQuad } from 'three-stdlib';\nconst PortalMaterialImpl = shaderMaterial({\n  blur: 0,\n  map: null,\n  sdf: null,\n  size: 0,\n  resolution: new THREE.Vector2()\n}, `varying vec2 vUv;\n   void main() {\n     gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n     vUv = uv;\n   }`, `uniform sampler2D sdf;\n   uniform sampler2D map;\n   uniform float blur;\n   uniform float size;\n   uniform float time;\n   uniform vec2 resolution;\n   varying vec2 vUv;\n   #include <packing>\n   void main() {\n     vec2 uv = gl_FragCoord.xy / resolution.xy;\n     vec4 t = texture2D(map, uv);\n     float k = blur;\n     float d = texture2D(sdf, vUv).r/size;\n     float alpha = 1.0 - smoothstep(0.0, 1.0, clamp(d/k + 1.0, 0.0, 1.0));\n     gl_FragColor = vec4(t.rgb, blur == 0.0 ? t.a : t.a * alpha);\n     #include <tonemapping_fragment>\n     #include <encodings_fragment>\n   }`);\nconst MeshPortalMaterial = /*#__PURE__*/React.forwardRef((_ref, fref) => {\n  let {\n    children,\n    blur,\n    eventPriority,\n    renderPriority,\n    worldUnits = false,\n    resolution = 512,\n    ...props\n  } = _ref;\n  extend({\n    PortalMaterialImpl\n  });\n  const ref = React.useRef(null);\n  const {\n    gl,\n    size,\n    events,\n    viewport\n  } = useThree();\n  const maskRenderTarget = useFBO(resolution, resolution);\n  React.useLayoutEffect(() => {\n    var _ref$current;\n    let mask = (_ref$current = ref.current) == null ? void 0 : _ref$current.__r3f.parent;\n    if (!mask) return; // Apply the SDF mask only once\n\n    if (blur && ref.current.sdf === null) {\n      const tempMesh = new THREE.Mesh(mask.geometry, new THREE.MeshBasicMaterial());\n      const boundingBox = new THREE.Box3().setFromBufferAttribute(tempMesh.geometry.attributes.position);\n      const orthoCam = new THREE.OrthographicCamera(boundingBox.min.x * (1 + 2 / resolution), boundingBox.max.x * (1 + 2 / resolution), boundingBox.max.y * (1 + 2 / resolution), boundingBox.min.y * (1 + 2 / resolution), 0.1, 1000);\n      orthoCam.position.set(0, 0, 1);\n      orthoCam.lookAt(0, 0, 0);\n      gl.setRenderTarget(maskRenderTarget);\n      gl.render(tempMesh, orthoCam);\n      const sg = makeSDFGenerator(resolution, resolution, gl);\n      const sdf = sg(maskRenderTarget.texture);\n      const readSdf = new Float32Array(resolution * resolution);\n      gl.readRenderTargetPixels(sdf, 0, 0, resolution, resolution, readSdf); // Get smallest value in sdf\n\n      let min = Infinity;\n      for (let i = 0; i < readSdf.length; i++) {\n        if (readSdf[i] < min) min = readSdf[i];\n      }\n      min = -min;\n      ref.current.size = min;\n      ref.current.sdf = sdf.texture;\n      gl.setRenderTarget(null);\n    }\n  }, [resolution, blur]);\n  React.useImperativeHandle(fref, () => ref.current);\n  return /*#__PURE__*/React.createElement(\"portalMaterialImpl\", _extends({\n    ref: ref,\n    blur: blur,\n    resolution: [size.width * viewport.dpr, size.height * viewport.dpr],\n    toneMapped: false,\n    attach: \"material\"\n  }, props), /*#__PURE__*/React.createElement(RenderTexture, {\n    attach: \"map\",\n    eventPriority: eventPriority,\n    renderPriority: renderPriority,\n    compute: events.compute\n  }, children, /*#__PURE__*/React.createElement(CopyMatrix, {\n    material: ref,\n    worldUnits: worldUnits\n  })));\n});\nfunction CopyMatrix(_ref2) {\n  let {\n    material,\n    worldUnits\n  } = _ref2;\n  const scene = useThree(state => state.scene);\n  React.useLayoutEffect(() => {\n    scene.matrixAutoUpdate = false;\n  }, []);\n  useFrame(() => {\n    var _material$current;\n    let parent = material == null ? void 0 : (_material$current = material.current) == null ? void 0 : _material$current.__r3f.parent;\n    if (parent) {\n      if (!worldUnits) scene.matrixWorld.copy(parent.matrixWorld);else scene.matrixWorld.identity();\n    }\n  });\n  return /*#__PURE__*/React.createElement(React.Fragment, null);\n}\nconst makeSDFGenerator = (clientWidth, clientHeight, renderer) => {\n  let finalTarget = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.LinearMipmapLinearFilter,\n    magFilter: THREE.LinearFilter,\n    type: THREE.FloatType,\n    format: THREE.RedFormat,\n    generateMipmaps: true\n  });\n  let outsideRenderTarget = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.NearestFilter,\n    magFilter: THREE.NearestFilter\n  });\n  let insideRenderTarget = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.NearestFilter,\n    magFilter: THREE.NearestFilter\n  });\n  let outsideRenderTarget2 = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.NearestFilter,\n    magFilter: THREE.NearestFilter\n  });\n  let insideRenderTarget2 = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.NearestFilter,\n    magFilter: THREE.NearestFilter\n  });\n  let outsideRenderTargetFinal = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.NearestFilter,\n    magFilter: THREE.NearestFilter,\n    type: THREE.FloatType,\n    format: THREE.RedFormat\n  });\n  let insideRenderTargetFinal = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.NearestFilter,\n    magFilter: THREE.NearestFilter,\n    type: THREE.FloatType,\n    format: THREE.RedFormat\n  });\n  const uvRender = new FullScreenQuad(new THREE.ShaderMaterial({\n    uniforms: {\n      tex: {\n        value: null\n      }\n    },\n    vertexShader: /*glsl*/\n    `\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }`,\n    fragmentShader: /*glsl*/\n    `\n        uniform sampler2D tex;\n        varying vec2 vUv;\n        #include <packing>\n        void main() {\n          gl_FragColor = pack2HalfToRGBA(vUv * (round(texture2D(tex, vUv).x)));\n        }`\n  }));\n  const uvRenderInside = new FullScreenQuad(new THREE.ShaderMaterial({\n    uniforms: {\n      tex: {\n        value: null\n      }\n    },\n    vertexShader: /*glsl*/\n    `\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }`,\n    fragmentShader: /*glsl*/\n    `\n        uniform sampler2D tex;\n        varying vec2 vUv;\n        #include <packing>\n        void main() {\n          gl_FragColor = pack2HalfToRGBA(vUv * (1.0 - round(texture2D(tex, vUv).x)));\n        }`\n  }));\n  const jumpFloodRender = new FullScreenQuad(new THREE.ShaderMaterial({\n    uniforms: {\n      tex: {\n        value: null\n      },\n      offset: {\n        value: 0.0\n      },\n      level: {\n        value: 0.0\n      },\n      maxSteps: {\n        value: 0.0\n      }\n    },\n    vertexShader: /*glsl*/\n    `\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }`,\n    fragmentShader: /*glsl*/\n    `\n        varying vec2 vUv;\n        uniform sampler2D tex;\n        uniform float offset;\n        uniform float level;\n        uniform float maxSteps;\n        #include <packing>\n        void main() {\n          float closestDist = 9999999.9;\n          vec2 closestPos = vec2(0.0);\n          for (float x = -1.0; x <= 1.0; x += 1.0) {\n            for (float y = -1.0; y <= 1.0; y += 1.0) {\n              vec2 voffset = vUv;\n              voffset += vec2(x, y) * vec2(${1 / clientWidth}, ${1 / clientHeight}) * offset;\n              vec2 pos = unpackRGBATo2Half(texture2D(tex, voffset));\n              float dist = distance(pos.xy, vUv);\n              if(pos.x != 0.0 && pos.y != 0.0 && dist < closestDist) {\n                closestDist = dist;\n                closestPos = pos;\n              }\n            }\n          }\n          gl_FragColor = pack2HalfToRGBA(closestPos);\n        }`\n  }));\n  const distanceFieldRender = new FullScreenQuad(new THREE.ShaderMaterial({\n    uniforms: {\n      tex: {\n        value: null\n      },\n      size: {\n        value: new THREE.Vector2(clientWidth, clientHeight)\n      }\n    },\n    vertexShader: /*glsl*/\n    `\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }`,\n    fragmentShader: /*glsl*/\n    `\n        varying vec2 vUv;\n        uniform sampler2D tex;\n        uniform vec2 size;\n        #include <packing>\n        void main() {\n          gl_FragColor = vec4(distance(size * unpackRGBATo2Half(texture2D(tex, vUv)), size * vUv), 0.0, 0.0, 0.0);\n        }`\n  }));\n  const compositeRender = new FullScreenQuad(new THREE.ShaderMaterial({\n    uniforms: {\n      inside: {\n        value: insideRenderTargetFinal.texture\n      },\n      outside: {\n        value: outsideRenderTargetFinal.texture\n      },\n      tex: {\n        value: null\n      }\n    },\n    vertexShader: /*glsl*/\n    `\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }`,\n    fragmentShader: /*glsl*/\n    `\n        varying vec2 vUv;\n        uniform sampler2D inside;\n        uniform sampler2D outside;\n        uniform sampler2D tex;\n        #include <packing>\n        void main() {\n          float i = texture2D(inside, vUv).x;\n          float o =texture2D(outside, vUv).x;\n          if (texture2D(tex, vUv).x == 0.0) {\n            gl_FragColor = vec4(o, 0.0, 0.0, 0.0);\n          } else {\n            gl_FragColor = vec4(-i, 0.0, 0.0, 0.0);\n          }\n        }`\n  }));\n  return image => {\n    let ft = finalTarget;\n    image.minFilter = THREE.NearestFilter;\n    image.magFilter = THREE.NearestFilter;\n    uvRender.material.uniforms.tex.value = image;\n    renderer.setRenderTarget(outsideRenderTarget);\n    uvRender.render(renderer);\n    const passes = Math.ceil(Math.log(Math.max(clientWidth, clientHeight)) / Math.log(2.0));\n    let lastTarget = outsideRenderTarget;\n    let target = null;\n    for (let i = 0; i < passes; i++) {\n      const offset = Math.pow(2, passes - i - 1);\n      target = lastTarget === outsideRenderTarget ? outsideRenderTarget2 : outsideRenderTarget;\n      jumpFloodRender.material.uniforms.level.value = i;\n      jumpFloodRender.material.uniforms.maxSteps.value = passes;\n      jumpFloodRender.material.uniforms.offset.value = offset;\n      jumpFloodRender.material.uniforms.tex.value = lastTarget.texture;\n      renderer.setRenderTarget(target);\n      jumpFloodRender.render(renderer);\n      lastTarget = target;\n    }\n    renderer.setRenderTarget(outsideRenderTargetFinal);\n    distanceFieldRender.material.uniforms.tex.value = target.texture;\n    distanceFieldRender.render(renderer);\n    uvRenderInside.material.uniforms.tex.value = image;\n    renderer.setRenderTarget(insideRenderTarget);\n    uvRenderInside.render(renderer);\n    lastTarget = insideRenderTarget;\n    for (let i = 0; i < passes; i++) {\n      const offset = Math.pow(2, passes - i - 1);\n      target = lastTarget === insideRenderTarget ? insideRenderTarget2 : insideRenderTarget;\n      jumpFloodRender.material.uniforms.level.value = i;\n      jumpFloodRender.material.uniforms.maxSteps.value = passes;\n      jumpFloodRender.material.uniforms.offset.value = offset;\n      jumpFloodRender.material.uniforms.tex.value = lastTarget.texture;\n      renderer.setRenderTarget(target);\n      jumpFloodRender.render(renderer);\n      lastTarget = target;\n    }\n    renderer.setRenderTarget(insideRenderTargetFinal);\n    distanceFieldRender.material.uniforms.tex.value = target.texture;\n    distanceFieldRender.render(renderer);\n    renderer.setRenderTarget(ft);\n    compositeRender.material.uniforms.tex.value = image;\n    compositeRender.render(renderer);\n    renderer.setRenderTarget(null);\n    return ft;\n  };\n};\nexport { MeshPortalMaterial };","map":{"version":3,"names":["_extends","THREE","React","extend","useThree","useFrame","useFBO","RenderTexture","shaderMaterial","FullScreenQuad","PortalMaterialImpl","blur","map","sdf","size","resolution","Vector2","MeshPortalMaterial","forwardRef","_ref","fref","children","eventPriority","renderPriority","worldUnits","props","ref","useRef","gl","events","viewport","maskRenderTarget","useLayoutEffect","_ref$current","mask","current","__r3f","parent","tempMesh","Mesh","geometry","MeshBasicMaterial","boundingBox","Box3","setFromBufferAttribute","attributes","position","orthoCam","OrthographicCamera","min","x","max","y","set","lookAt","setRenderTarget","render","sg","makeSDFGenerator","texture","readSdf","Float32Array","readRenderTargetPixels","Infinity","i","length","useImperativeHandle","createElement","width","dpr","height","toneMapped","attach","compute","CopyMatrix","material","_ref2","scene","state","matrixAutoUpdate","_material$current","matrixWorld","copy","identity","Fragment","clientWidth","clientHeight","renderer","finalTarget","WebGLRenderTarget","minFilter","LinearMipmapLinearFilter","magFilter","LinearFilter","type","FloatType","format","RedFormat","generateMipmaps","outsideRenderTarget","NearestFilter","insideRenderTarget","outsideRenderTarget2","insideRenderTarget2","outsideRenderTargetFinal","insideRenderTargetFinal","uvRender","ShaderMaterial","uniforms","tex","value","vertexShader","fragmentShader","uvRenderInside","jumpFloodRender","offset","level","maxSteps","distanceFieldRender","compositeRender","inside","outside","image","ft","passes","Math","ceil","log","lastTarget","target","pow"],"sources":["C:/Users/Lisboa/Desktop/Lidia/Front-End - Projects/3DModel/node_modules/@react-three/drei/core/MeshPortalMaterial.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { useFBO } from './useFBO.js';\nimport { RenderTexture } from './RenderTexture.js';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { FullScreenQuad } from 'three-stdlib';\n\nconst PortalMaterialImpl = shaderMaterial({\n  blur: 0,\n  map: null,\n  sdf: null,\n  size: 0,\n  resolution: new THREE.Vector2()\n}, `varying vec2 vUv;\n   void main() {\n     gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n     vUv = uv;\n   }`, `uniform sampler2D sdf;\n   uniform sampler2D map;\n   uniform float blur;\n   uniform float size;\n   uniform float time;\n   uniform vec2 resolution;\n   varying vec2 vUv;\n   #include <packing>\n   void main() {\n     vec2 uv = gl_FragCoord.xy / resolution.xy;\n     vec4 t = texture2D(map, uv);\n     float k = blur;\n     float d = texture2D(sdf, vUv).r/size;\n     float alpha = 1.0 - smoothstep(0.0, 1.0, clamp(d/k + 1.0, 0.0, 1.0));\n     gl_FragColor = vec4(t.rgb, blur == 0.0 ? t.a : t.a * alpha);\n     #include <tonemapping_fragment>\n     #include <encodings_fragment>\n   }`);\nconst MeshPortalMaterial = /*#__PURE__*/React.forwardRef(({\n  children,\n  blur,\n  eventPriority,\n  renderPriority,\n  worldUnits = false,\n  resolution = 512,\n  ...props\n}, fref) => {\n  extend({\n    PortalMaterialImpl\n  });\n  const ref = React.useRef(null);\n  const {\n    gl,\n    size,\n    events,\n    viewport\n  } = useThree();\n  const maskRenderTarget = useFBO(resolution, resolution);\n  React.useLayoutEffect(() => {\n    var _ref$current;\n\n    let mask = (_ref$current = ref.current) == null ? void 0 : _ref$current.__r3f.parent;\n    if (!mask) return; // Apply the SDF mask only once\n\n    if (blur && ref.current.sdf === null) {\n      const tempMesh = new THREE.Mesh(mask.geometry, new THREE.MeshBasicMaterial());\n      const boundingBox = new THREE.Box3().setFromBufferAttribute(tempMesh.geometry.attributes.position);\n      const orthoCam = new THREE.OrthographicCamera(boundingBox.min.x * (1 + 2 / resolution), boundingBox.max.x * (1 + 2 / resolution), boundingBox.max.y * (1 + 2 / resolution), boundingBox.min.y * (1 + 2 / resolution), 0.1, 1000);\n      orthoCam.position.set(0, 0, 1);\n      orthoCam.lookAt(0, 0, 0);\n      gl.setRenderTarget(maskRenderTarget);\n      gl.render(tempMesh, orthoCam);\n      const sg = makeSDFGenerator(resolution, resolution, gl);\n      const sdf = sg(maskRenderTarget.texture);\n      const readSdf = new Float32Array(resolution * resolution);\n      gl.readRenderTargetPixels(sdf, 0, 0, resolution, resolution, readSdf); // Get smallest value in sdf\n\n      let min = Infinity;\n\n      for (let i = 0; i < readSdf.length; i++) {\n        if (readSdf[i] < min) min = readSdf[i];\n      }\n\n      min = -min;\n      ref.current.size = min;\n      ref.current.sdf = sdf.texture;\n      gl.setRenderTarget(null);\n    }\n  }, [resolution, blur]);\n  React.useImperativeHandle(fref, () => ref.current);\n  return /*#__PURE__*/React.createElement(\"portalMaterialImpl\", _extends({\n    ref: ref,\n    blur: blur,\n    resolution: [size.width * viewport.dpr, size.height * viewport.dpr],\n    toneMapped: false,\n    attach: \"material\"\n  }, props), /*#__PURE__*/React.createElement(RenderTexture, {\n    attach: \"map\",\n    eventPriority: eventPriority,\n    renderPriority: renderPriority,\n    compute: events.compute\n  }, children, /*#__PURE__*/React.createElement(CopyMatrix, {\n    material: ref,\n    worldUnits: worldUnits\n  })));\n});\n\nfunction CopyMatrix({\n  material,\n  worldUnits\n}) {\n  const scene = useThree(state => state.scene);\n  React.useLayoutEffect(() => {\n    scene.matrixAutoUpdate = false;\n  }, []);\n  useFrame(() => {\n    var _material$current;\n\n    let parent = material == null ? void 0 : (_material$current = material.current) == null ? void 0 : _material$current.__r3f.parent;\n\n    if (parent) {\n      if (!worldUnits) scene.matrixWorld.copy(parent.matrixWorld);else scene.matrixWorld.identity();\n    }\n  });\n  return /*#__PURE__*/React.createElement(React.Fragment, null);\n}\n\nconst makeSDFGenerator = (clientWidth, clientHeight, renderer) => {\n  let finalTarget = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.LinearMipmapLinearFilter,\n    magFilter: THREE.LinearFilter,\n    type: THREE.FloatType,\n    format: THREE.RedFormat,\n    generateMipmaps: true\n  });\n  let outsideRenderTarget = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.NearestFilter,\n    magFilter: THREE.NearestFilter\n  });\n  let insideRenderTarget = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.NearestFilter,\n    magFilter: THREE.NearestFilter\n  });\n  let outsideRenderTarget2 = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.NearestFilter,\n    magFilter: THREE.NearestFilter\n  });\n  let insideRenderTarget2 = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.NearestFilter,\n    magFilter: THREE.NearestFilter\n  });\n  let outsideRenderTargetFinal = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.NearestFilter,\n    magFilter: THREE.NearestFilter,\n    type: THREE.FloatType,\n    format: THREE.RedFormat\n  });\n  let insideRenderTargetFinal = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.NearestFilter,\n    magFilter: THREE.NearestFilter,\n    type: THREE.FloatType,\n    format: THREE.RedFormat\n  });\n  const uvRender = new FullScreenQuad(new THREE.ShaderMaterial({\n    uniforms: {\n      tex: {\n        value: null\n      }\n    },\n    vertexShader:\n    /*glsl*/\n    `\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }`,\n    fragmentShader:\n    /*glsl*/\n    `\n        uniform sampler2D tex;\n        varying vec2 vUv;\n        #include <packing>\n        void main() {\n          gl_FragColor = pack2HalfToRGBA(vUv * (round(texture2D(tex, vUv).x)));\n        }`\n  }));\n  const uvRenderInside = new FullScreenQuad(new THREE.ShaderMaterial({\n    uniforms: {\n      tex: {\n        value: null\n      }\n    },\n    vertexShader:\n    /*glsl*/\n    `\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }`,\n    fragmentShader:\n    /*glsl*/\n    `\n        uniform sampler2D tex;\n        varying vec2 vUv;\n        #include <packing>\n        void main() {\n          gl_FragColor = pack2HalfToRGBA(vUv * (1.0 - round(texture2D(tex, vUv).x)));\n        }`\n  }));\n  const jumpFloodRender = new FullScreenQuad(new THREE.ShaderMaterial({\n    uniforms: {\n      tex: {\n        value: null\n      },\n      offset: {\n        value: 0.0\n      },\n      level: {\n        value: 0.0\n      },\n      maxSteps: {\n        value: 0.0\n      }\n    },\n    vertexShader:\n    /*glsl*/\n    `\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }`,\n    fragmentShader:\n    /*glsl*/\n    `\n        varying vec2 vUv;\n        uniform sampler2D tex;\n        uniform float offset;\n        uniform float level;\n        uniform float maxSteps;\n        #include <packing>\n        void main() {\n          float closestDist = 9999999.9;\n          vec2 closestPos = vec2(0.0);\n          for (float x = -1.0; x <= 1.0; x += 1.0) {\n            for (float y = -1.0; y <= 1.0; y += 1.0) {\n              vec2 voffset = vUv;\n              voffset += vec2(x, y) * vec2(${1 / clientWidth}, ${1 / clientHeight}) * offset;\n              vec2 pos = unpackRGBATo2Half(texture2D(tex, voffset));\n              float dist = distance(pos.xy, vUv);\n              if(pos.x != 0.0 && pos.y != 0.0 && dist < closestDist) {\n                closestDist = dist;\n                closestPos = pos;\n              }\n            }\n          }\n          gl_FragColor = pack2HalfToRGBA(closestPos);\n        }`\n  }));\n  const distanceFieldRender = new FullScreenQuad(new THREE.ShaderMaterial({\n    uniforms: {\n      tex: {\n        value: null\n      },\n      size: {\n        value: new THREE.Vector2(clientWidth, clientHeight)\n      }\n    },\n    vertexShader:\n    /*glsl*/\n    `\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }`,\n    fragmentShader:\n    /*glsl*/\n    `\n        varying vec2 vUv;\n        uniform sampler2D tex;\n        uniform vec2 size;\n        #include <packing>\n        void main() {\n          gl_FragColor = vec4(distance(size * unpackRGBATo2Half(texture2D(tex, vUv)), size * vUv), 0.0, 0.0, 0.0);\n        }`\n  }));\n  const compositeRender = new FullScreenQuad(new THREE.ShaderMaterial({\n    uniforms: {\n      inside: {\n        value: insideRenderTargetFinal.texture\n      },\n      outside: {\n        value: outsideRenderTargetFinal.texture\n      },\n      tex: {\n        value: null\n      }\n    },\n    vertexShader:\n    /*glsl*/\n    `\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }`,\n    fragmentShader:\n    /*glsl*/\n    `\n        varying vec2 vUv;\n        uniform sampler2D inside;\n        uniform sampler2D outside;\n        uniform sampler2D tex;\n        #include <packing>\n        void main() {\n          float i = texture2D(inside, vUv).x;\n          float o =texture2D(outside, vUv).x;\n          if (texture2D(tex, vUv).x == 0.0) {\n            gl_FragColor = vec4(o, 0.0, 0.0, 0.0);\n          } else {\n            gl_FragColor = vec4(-i, 0.0, 0.0, 0.0);\n          }\n        }`\n  }));\n  return image => {\n    let ft = finalTarget;\n    image.minFilter = THREE.NearestFilter;\n    image.magFilter = THREE.NearestFilter;\n    uvRender.material.uniforms.tex.value = image;\n    renderer.setRenderTarget(outsideRenderTarget);\n    uvRender.render(renderer);\n    const passes = Math.ceil(Math.log(Math.max(clientWidth, clientHeight)) / Math.log(2.0));\n    let lastTarget = outsideRenderTarget;\n    let target = null;\n\n    for (let i = 0; i < passes; i++) {\n      const offset = Math.pow(2, passes - i - 1);\n      target = lastTarget === outsideRenderTarget ? outsideRenderTarget2 : outsideRenderTarget;\n      jumpFloodRender.material.uniforms.level.value = i;\n      jumpFloodRender.material.uniforms.maxSteps.value = passes;\n      jumpFloodRender.material.uniforms.offset.value = offset;\n      jumpFloodRender.material.uniforms.tex.value = lastTarget.texture;\n      renderer.setRenderTarget(target);\n      jumpFloodRender.render(renderer);\n      lastTarget = target;\n    }\n\n    renderer.setRenderTarget(outsideRenderTargetFinal);\n    distanceFieldRender.material.uniforms.tex.value = target.texture;\n    distanceFieldRender.render(renderer);\n    uvRenderInside.material.uniforms.tex.value = image;\n    renderer.setRenderTarget(insideRenderTarget);\n    uvRenderInside.render(renderer);\n    lastTarget = insideRenderTarget;\n\n    for (let i = 0; i < passes; i++) {\n      const offset = Math.pow(2, passes - i - 1);\n      target = lastTarget === insideRenderTarget ? insideRenderTarget2 : insideRenderTarget;\n      jumpFloodRender.material.uniforms.level.value = i;\n      jumpFloodRender.material.uniforms.maxSteps.value = passes;\n      jumpFloodRender.material.uniforms.offset.value = offset;\n      jumpFloodRender.material.uniforms.tex.value = lastTarget.texture;\n      renderer.setRenderTarget(target);\n      jumpFloodRender.render(renderer);\n      lastTarget = target;\n    }\n\n    renderer.setRenderTarget(insideRenderTargetFinal);\n    distanceFieldRender.material.uniforms.tex.value = target.texture;\n    distanceFieldRender.render(renderer);\n    renderer.setRenderTarget(ft);\n    compositeRender.material.uniforms.tex.value = image;\n    compositeRender.render(renderer);\n    renderer.setRenderTarget(null);\n    return ft;\n  };\n};\n\nexport { MeshPortalMaterial };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}